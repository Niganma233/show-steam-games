---
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import { sidebarLayoutConfig } from "../config";
import MainGridLayout from "../layouts/MainGridLayout.astro";

// --- â¬‡ï¸ åœ¨è¿™é‡Œé…ç½®ä½ çš„æ¸¸æˆåˆ—è¡¨ â¬‡ï¸ ---
const localGameList = [
  {
    title: "", //æ¸¸æˆåç§°
    cover: "", //å°é¢
    status: "", //çŠ¶æ€
    rating: 5.0, //è¯„åˆ†0-5
    playtime: "1h", //æ¸¸æˆæ—¶é•¿
    description: "", //æ¸¸æˆç®€ä»‹
    tags: ["",], //æ ‡ç­¾
    link: "", //æ¸¸æˆé“¾æ¥
    year: "" //æ¸¸æˆå‘å”®å¹´ä»½
  },
];

// --- â¬†ï¸ é…ç½®ç»“æŸ â¬†ï¸ ---

// é¡µé¢åŸºç¡€ä¿¡æ¯é…ç½®
const PAGE_TITLE = "æ¸¸æˆåº“";
const PAGE_SUBTITLE = "æˆ‘çš„ Steam æ¸¸æˆæ”¶è—ä¸è®°å½•";

// æ£€æŸ¥æ˜¯å¦ä¸ºåŒä¾§è¾¹æ æ¨¡å¼
const isBothSidebarMode = sidebarLayoutConfig.position === "both";

// ä¸ºäº†é¿å…ä¿®æ”¹å…¨å±€ i18n æ–‡ä»¶ï¼Œè¿™é‡Œå®šä¹‰é¡µé¢å†…éƒ¨ä½¿ç”¨çš„æ–‡æœ¬
const i18nLocal = {
    filterAll: "å…¨éƒ¨",
    statusPlaying: "æ­£åœ¨ç©",
    statusCompleted: "å·²é€šå…³",
    statusPlayed: "ç©è¿‡/æç½®",
    statusPlanned: "æƒ³ç©",
    empty: "æš‚æ— æ¸¸æˆ",
    emptyDesc: "è¯·åœ¨ games.astro æ–‡ä»¶ä¸­æ·»åŠ ä½ çš„æ¸¸æˆæ•°æ®",
};

// è·å–çŠ¶æ€çš„æ ·å¼å’Œå›¾æ ‡
function getStatusInfo(status: string) {
	switch (status) {
		case "playing":
			return {
				text: i18nLocal.statusPlaying,
				class: "bg-green-100 text-green-700 dark:bg-green-900/30 dark:text-green-300",
				icon: "â–¶",
			};
		case "completed":
			return {
				text: i18nLocal.statusCompleted,
				class: "bg-yellow-100 text-yellow-700 dark:bg-yellow-900/30 dark:text-yellow-300",
				icon: "ğŸ†",
			};
		case "played":
			return {
				text: i18nLocal.statusPlayed,
				class: "bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-300",
				icon: "ğŸ’¾",
			};
		case "planned":
			return {
				text: i18nLocal.statusPlanned,
				class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
				icon: "ğŸ“…",
			};
		default:
			return {
				text: status,
				class: "bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-300",
				icon: "?",
			};
	}
}

// ç»Ÿè®¡æ•°æ®
const stats = {
	total: localGameList.length,
	playing: localGameList.filter((g) => g.status === "playing").length,
	completed: localGameList.filter((g) => g.status === "completed").length,
};
---

<MainGridLayout title={PAGE_TITLE} description={PAGE_SUBTITLE}>
  <div class="flex w-full rounded-[var(--radius-large)] overflow-hidden relative min-h-32">
    <div class="card-base z-10 px-9 py-6 relative w-full">
      <!-- é¡µé¢æ ‡é¢˜åŒºåŸŸ -->
      <div class="relative w-full mb-8">
        <div class="mb-6">
          <h1 class="text-4xl font-bold text-black/90 dark:text-white/90 mb-2 relative
                    before:w-1 before:h-8 before:rounded-md before:bg-[var(--primary)]
                    before:absolute before:top-1/2 before:-translate-y-1/2 before:-left-4">
            {PAGE_TITLE}
          </h1>
          <p class="text-black/75 dark:text-white/75">
            {PAGE_SUBTITLE} Â· {stats.total} æ¬¾æ¸¸æˆ Â· {stats.playing} æ­£åœ¨ç©
          </p>
        </div>
        
        <!-- è¿‡æ»¤æŒ‰é’® -->
        <div class="mb-6">
          <div class="filter-container flex flex-wrap gap-2">
            <button class="filter-tag active" data-status="all">{i18nLocal.filterAll}</button>
            <button class="filter-tag" data-status="playing">{i18nLocal.statusPlaying}</button>
            <button class="filter-tag" data-status="completed">{i18nLocal.statusCompleted}</button>
            <button class="filter-tag" data-status="played">{i18nLocal.statusPlayed}</button>
            <button class="filter-tag" data-status="planned">{i18nLocal.statusPlanned}</button>
          </div>
        </div>
      </div>

      <!-- æ¸¸æˆåˆ—è¡¨ Grid -->
      <div class="mb-8">
        {localGameList.length > 0 ? (
          <div id="game-list-container" class={`game-grid-container grid gap-4 md:gap-6 list-mode ${
            isBothSidebarMode ? "both-sidebar" : "single-sidebar"
          }`}>
            {localGameList.map(game => {
              const statusInfo = getStatusInfo(game.status);
              
              return (
                <div class="group relative bg-[var(--card-bg)] border border-[var(--line-divider)] rounded-[var(--radius-large)] overflow-hidden transition-all duration-300 hover:shadow-lg hover:scale-[1.02]" data-game-status={game.status}>
                  <!-- å°é¢åŒºåŸŸ - 2:3 æ¯”ä¾‹ (Steamå°é¢æ ‡å‡†) -->
                  <div class="relative aspect-[2/3] overflow-hidden bg-black/5 dark:bg-white/5">
                    <a href={game.link} target="_blank" rel="noopener noreferrer" class="block w-full h-full">
                      <ImageWrapper 
                        src={game.cover} 
                        alt={game.title}
                        class="w-full h-full object-cover transition-transform duration-500 group-hover:scale-110"
                      />
                      <!-- æ‚¬åœé®ç½© -->
                      <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                        <div class="absolute inset-0 flex items-center justify-center">
                          <div class="w-12 h-12 rounded-full bg-white/90 flex items-center justify-center shadow-lg transform scale-0 group-hover:scale-100 transition-transform duration-300 delay-75">
                            <svg class="w-6 h-6 text-black ml-1" fill="currentColor" viewBox="0 0 24 24">
                              <path d="M8 5v14l11-7z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </a>
                    
                    <!-- å·¦ä¸Šè§’ï¼šçŠ¶æ€æ ‡ç­¾ -->
                    <div class={`absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-medium backdrop-blur-md shadow-sm ${statusInfo.class}`}>
                      <span class="mr-1">{statusInfo.icon}</span>
                      <span>{statusInfo.text}</span>
                    </div>
                    
                    <!-- å³ä¸Šè§’ï¼šè¯„åˆ† -->
                    {game.rating > 0 && (
                      <div class="absolute top-2 right-2 bg-black/70 text-white px-2 py-1 rounded-md text-xs font-medium flex items-center gap-1 backdrop-blur-md">
                        <svg class="w-3 h-3 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                        </svg>
                        <span>{game.rating}</span>
                      </div>
                    )}

                    <!-- åº•éƒ¨ï¼šæ—¶é•¿ä¿¡æ¯ (ä»…åœ¨éPlannedçŠ¶æ€æ˜¾ç¤º) -->
                    {game.status !== 'planned' && (
                        <div class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent">
                             <div class="text-white text-xs font-medium flex justify-between px-1">
                                <span>{game.year}</span>
                                <span>{game.playtime}</span>
                             </div>
                        </div>
                    )}
                  </div>
                  
                  <!-- å†…å®¹åŒºåŸŸ -->
                  <div class="p-3">
                    <h3 class="text-sm font-bold text-black/90 dark:text-white/90 mb-1 line-clamp-1 leading-tight" title={game.title}>{game.title}</h3>
                    <p class="text-black/60 dark:text-white/60 text-xs mb-2 line-clamp-2 h-8 leading-4">{game.description}</p>
                    
                    <!-- æ ‡ç­¾ -->
                    <div class="flex flex-wrap gap-1 mt-1">
                      {game.tags && game.tags.slice(0, 3).map(tag => (
                        <span class="px-1.5 py-0.5 bg-[var(--btn-regular-bg)] text-black/60 dark:text-white/60 rounded text-[10px]">{tag}</span>
                      ))}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        ) : (
          <div class="text-center py-12">
            <div class="text-5xl mb-4">ğŸ®</div>
            <h3 class="text-xl font-medium text-black/80 dark:text-white/80 mb-2">
              {i18nLocal.empty}
            </h3>
            <p class="text-black/60 dark:text-white/60">
              {i18nLocal.emptyDesc}
            </p>
          </div>
        )}
      </div>
    </div>
  </div>

<script is:inline define:vars={{ isBothSidebarMode }}>
// å¸ƒå±€ç®¡ç†ä¸åŠ¨ç”»è„šæœ¬
(function() {
    const CONTAINER_ID = "game-list-container";
    const ITEM_ATTR = "data-game-status";

    // åˆå§‹åŒ–å»¶è¿Ÿï¼Œç­‰å¾…DOMå°±ç»ª
    setTimeout(() => {
        const container = document.getElementById(CONTAINER_ID);
        if (!container) return;

        // åˆå§‹åŒ–å¸ƒå±€ç®¡ç†å™¨
        if (typeof window.layoutManager !== 'undefined') {
            window.layoutManager.init(isBothSidebarMode);
            const currentLayout = window.layoutManager.getLayout();
            updateListLayout(currentLayout);
            window.layoutManager.checkScreenSizeAndAdjust();
        } else {
            // å¤‡ç”¨åˆå§‹åŒ–
            setTimeout(() => {
                if (typeof window.layoutManager !== 'undefined') {
                    window.layoutManager.init(isBothSidebarMode);
                    updateListLayout(window.layoutManager.getLayout());
                }
            }, 300);
        }
    }, 50);

    function updateListLayout(layout) {
        const container = document.getElementById(CONTAINER_ID);
        if (!container) return;

        // FLIP åŠ¨ç”» - è®°å½•èµ·å§‹ä½ç½®
        const items = Array.from(document.querySelectorAll(`[${ITEM_ATTR}]`));
        const firstPositions = new Map();
        items.forEach(item => {
            const rect = item.getBoundingClientRect();
            firstPositions.set(item, { left: rect.left, top: rect.top });
        });
        
        // åˆ‡æ¢ Class
        container.classList.remove("list-mode", "grid-mode");
        const rightSidebar = document.querySelector('.right-sidebar-container');
        const mainGrid = document.getElementById('main-grid');

        if (layout === "grid") {
            container.classList.add("grid-mode");
            container.classList.add("grid", "grid-cols-1", "md:grid-cols-2", "lg:grid-cols-3");
            container.classList.remove("flex", "flex-col");
            
            if (rightSidebar) {
                rightSidebar.style.display = 'none';
                rightSidebar.classList.add('hidden-in-grid-mode');
            }
            if (mainGrid) {
                mainGrid.style.gridTemplateColumns = '17.5rem 1fr';
                mainGrid.classList.add('two-column-layout');
            }
        } else {
            container.classList.add("list-mode");
            container.classList.add("flex", "flex-col");
            container.classList.remove("grid", "grid-cols-1", "md:grid-cols-2", "lg:grid-cols-3");
            
            if (rightSidebar) {
                rightSidebar.style.display = '';
                rightSidebar.classList.remove('hidden-in-grid-mode');
            }
            if (mainGrid) {
                mainGrid.style.gridTemplateColumns = '';
                mainGrid.classList.remove('two-column-layout');
            }
        }

        // FLIP åŠ¨ç”» - æ’­æ”¾
        requestAnimationFrame(() => {
            const lastPositions = new Map();
            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                lastPositions.set(item, { left: rect.left, top: rect.top });
            });
            
            items.forEach(item => {
                const first = firstPositions.get(item);
                const last = lastPositions.get(item);
                if (first && last) {
                    const deltaX = first.left - last.left;
                    const deltaY = first.top - last.top;
                    item.style.transition = 'none';
                    item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                }
            });
            
            requestAnimationFrame(() => {
                items.forEach((item, index) => {
                    setTimeout(() => {
                        item.classList.add('card-animating');
                        item.style.transition = '';
                        item.style.transform = '';
                    }, index * 20);
                });
                setTimeout(() => {
                    items.forEach(item => {
                        item.classList.remove('card-animating');
                        item.style.transition = '';
                        item.style.transform = '';
                    });
                }, 500 + items.length * 20);
            });
        });
    }

    window.addEventListener("layoutChange", (event) => updateListLayout(event.detail.layout));
})();
</script>

<style>
    .card-base { container-type: inline-size; }
    
    /* å“åº”å¼ç½‘æ ¼åˆ—æ•°é…ç½® */
    .game-grid-container {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .game-grid-container.single-sidebar {
        @container (min-width: 900px) { grid-template-columns: repeat(5, 1fr); }
        @container (min-width: 600px) and (max-width: 899px) { grid-template-columns: repeat(3, 1fr); }
        @container (max-width: 599px) { grid-template-columns: repeat(2, 1fr); }
    }
    
    .game-grid-container.both-sidebar {
        @container (min-width: 950px) { grid-template-columns: repeat(5, 1fr); }
        @container (min-width: 650px) and (max-width: 949px) { grid-template-columns: repeat(4, 1fr); }
        @container (min-width: 480px) and (max-width: 649px) { grid-template-columns: repeat(3, 1fr); }
        @container (max-width: 479px) { grid-template-columns: repeat(2, 1fr); }
    }
    
    /* è¿‡æ»¤å™¨æ ·å¼ */
    .filter-container { display: flex; flex-wrap: wrap; gap: 0.5rem; }
    .filter-tag {
        padding: 0.5rem 1rem;
        border: 1px solid var(--line-divider);
        border-radius: var(--radius-large);
        background: var(--btn-regular-bg);
        color: var(--btn-content);
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
    }
    .filter-tag:hover:not(.active) {
        background: var(--btn-hover-bg);
        border-color: var(--primary);
        transform: translateY(-1px);
    }
    .filter-tag.active {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
    }
    .filter-tag.active:hover {
        background: var(--primary) !important;
        color: white !important;
        border-color: var(--primary) !important;
    }

    /* å¡ç‰‡åŠ¨ç”»æ ·å¼ */
    [data-game-status] { transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
    
    #game-list-container.grid-mode [data-game-status]:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
        z-index: 10;
    }
    #game-list-container.list-mode [data-game-status]:hover {
        transform: translateX(8px) scale(1.01);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        z-index: 10;
    }

    /* è¿‡æ»¤åŠ¨ç”»è¾…åŠ©ç±» */
    [data-game-status].hidden { display: none; }
    [data-game-status].card-animating {
        transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }
    [data-game-status].fade-out { opacity: 0; transform: scale(0.8); pointer-events: none; }
    [data-game-status].fade-in { opacity: 0; transform: scale(0.8); }
    [data-game-status].fade-in-active { opacity: 1; transform: scale(1); }
</style>

<script is:inline>
// è¿‡æ»¤é€»è¾‘è„šæœ¬
if (typeof window.gameFilterEventListeners === 'undefined') {
    window.gameFilterEventListeners = [];
}

function initFilterButtons() {
    const filterTags = document.querySelectorAll('.filter-tag');
    window.gameFilterEventListeners.forEach(listener => {
        const [element, type, handler] = listener;
        element.removeEventListener(type, handler);
    });
    window.gameFilterEventListeners = [];
    
    filterTags.forEach(tag => {
        const clickHandler = function() {
            if (this.classList.contains('active')) return;
            filterTags.forEach(t => t.classList.remove('active'));
            this.classList.add('active');
            
            const status = this.getAttribute('data-status');
            const items = Array.from(document.querySelectorAll('[data-game-status]'));
            const firstPositions = new Map();
            
            // è®°å½•åˆå§‹ä½ç½®
            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                firstPositions.set(item, { left: rect.left, top: rect.top });
            });
            
            const itemsToHide = [], itemsToShow = [], itemsToKeep = [];
            
            items.forEach(item => {
                const itemStatus = item.getAttribute('data-game-status');
                const shouldShow = status === 'all' || itemStatus === status;
                const isVisible = !item.classList.contains('hidden');
                
                if (shouldShow) {
                    isVisible ? itemsToKeep.push(item) : itemsToShow.push(item);
                } else {
                    if (isVisible) itemsToHide.push(item);
                }
            });
            
            // åŠ¨ç”»è¿‡ç¨‹
            itemsToHide.forEach(item => item.classList.add('fade-out'));
            
            setTimeout(() => {
                itemsToHide.forEach(item => {
                    item.classList.add('hidden');
                    item.classList.remove('fade-out');
                });
                itemsToShow.forEach(item => {
                    item.classList.remove('hidden');
                    item.classList.add('fade-in');
                    item.style.opacity = '0';
                    item.style.transform = 'scale(0.8)';
                    item.style.transition = 'none';
                });
                
                requestAnimationFrame(() => {
                    // FLIP æ ¸å¿ƒï¼šè®¡ç®—ä½ç§»å¹¶åº”ç”¨
                    const lastPositions = new Map();
                    [...itemsToKeep, ...itemsToShow].forEach(item => {
                        const rect = item.getBoundingClientRect();
                        lastPositions.set(item, { left: rect.left, top: rect.top });
                    });
                    
                    itemsToKeep.forEach(item => {
                        const first = firstPositions.get(item);
                        const last = lastPositions.get(item);
                        if (first && last) {
                            const deltaX = first.left - last.left;
                            const deltaY = first.top - last.top;
                            item.style.transition = 'none';
                            item.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        }
                    });
                    
                    // æ’­æ”¾åŠ¨ç”»
                    requestAnimationFrame(() => {
                        [...itemsToKeep, ...itemsToShow].forEach((item, index) => {
                            setTimeout(() => {
                                item.classList.add('card-animating');
                                if (itemsToKeep.includes(item)) {
                                    item.style.transition = '';
                                    item.style.transform = '';
                                }
                                if (itemsToShow.includes(item)) {
                                    item.classList.remove('fade-in');
                                    item.classList.add('fade-in-active');
                                    item.style.transition = '';
                                    item.style.opacity = '1';
                                    item.style.transform = 'scale(1)';
                                }
                            }, index * 10);
                        });
                        
                        setTimeout(() => {
                            [...itemsToKeep, ...itemsToShow].forEach(item => {
                                item.classList.remove('card-animating', 'fade-in-active');
                                item.style.transition = '';
                                item.style.transform = '';
                                item.style.opacity = '';
                            });
                        }, 500 + (itemsToKeep.length + itemsToShow.length) * 10);
                    });
                });
            }, 300);
        };
        
        tag.addEventListener('click', clickHandler);
        window.gameFilterEventListeners.push([tag, 'click', clickHandler]);
    });
}

document.addEventListener('DOMContentLoaded', initFilterButtons);
if (typeof window !== 'undefined' && window.swup) {
    window.swup.hooks.on('content:replace', () => setTimeout(initFilterButtons, 150));
}
</script>
</MainGridLayout>